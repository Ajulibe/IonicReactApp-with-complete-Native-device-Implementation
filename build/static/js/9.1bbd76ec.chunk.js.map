{"version":3,"sources":["../../../src/util/feature-check.ts","../../../src/util/models.ts","../../../src/filesystem/useFileSystem.ts","../../../src/filesystem/utils.ts","pages/NewMemory.tsx"],"names":["Camera","Plugins","Filesystem","NewMemory","useState","takenPhoto","setTakenPhoto","chosenMemoryType","setChosenMemoryType","memoriesCtx","useContext","MemoriesContext","history","useHistory","titleRef","useRef","filePickerRef","openFilePicker","current","click","takePhotoHandler","a","console","log","Capacitor","isPluginAvailable","getPhoto","resultType","CameraResultType","Uri","source","CameraSource","quality","width","photo","webPath","path","preview","addMemoryHandler","enteredTitle","value","toString","trim","length","alert","fileName","Date","getTime","base64FromPath","base64","writeFile","data","directory","FilesystemDirectory","Data","addMemory","goBack","replace","slot","defaultHref","position","type","ref","onIonChange","event","selectedMemoryType","detail","placeholder","className","src","alt","fill","onClick","icon","camera","hidden","onChange","file","target","files","fr","FileReader","onload","undefined","result","readAsDataURL"],"mappings":"wPAIM,GCKwC,MDL9B,CACZ,KAAG,EACH,KAAG,EACL,SAAS,EACT,UAAU,IAGN,EAAa,CACf,cAAa,CACT,wBAAmB,+BAAM,GAAO,CAAE,KAAK,IACvC,MAAG,CACC,IAAD,oBAAqB,OAC1B,KAAK,EACL,SAAS,EACT,UAAU,IAGZ,IAAG,CACH,MAAO,EACP,aAAY,+BAAM,GAAO,CAAE,KAAK,IAC5B,WAAM,+BAAM,GAAO,CAAE,KAAK,KAE9B,QAAO,CACP,KAAM,EACN,SAAQ,+BAAM,GAAO,CAAE,KAAK,IACxB,MAAC,+BAAM,GAAO,CAAE,KAAK,KAEzB,OAAM,CACF,SAAM,GAEV,UAAS,CACL,aAAQ,+BAAM,GAAO,CAAE,IAAK,cAAe,aAE/C,OAAM,CACN,QAAS,EACL,gBAAa,GAEjB,WAAU,CACN,cAAW,GAEf,YAAW,CACX,mBAAkB,+BAAM,GAAO,CAAE,IAAK,gBAAiB,YACnD,cAAW,OAAF,wBAAM,GAAO,CAAE,IAAK,gBAAiB,aAElD,QAAO,CACH,UAAO,GAEX,SAAQ,CACJ,YAAS,GAEf,QAAS,CACP,WAAY,IE1CT,IFkDJ,EAAoB,EAApB,EEjDiC,aFiDb,EEjD2B,iBFkD3C,IAAU,kBAAkB,IAAwB,EAAmB,GAAQ,GAAQ,IAAU,UG/DxG,SAAsB,EAAtB,GAAE,OAAF,wB,4CAAO,WAA8B,GAA9B,yFACkB,MAAM,GADxB,cACC,EADD,gBAEc,EAAS,OAFvB,cAEC,EAFD,yBAGE,IAAI,SAAQ,SAAC,EAAS,GAC3B,IAAM,EAAS,IAAI,WACnB,EAAO,QAAU,EACjB,EAAO,OAAS,WACe,kBAAlB,EAAO,OAChB,EAAQ,EAAO,QAEf,EAAO,mCAGX,EAAO,cAAc,OAblB,4C,0CCiCCA,G,OAAuBC,IAAvBD,QAAQE,EAAeD,IAAfC,WA+KDC,UA7Ka,WAAO,IAAD,EACIC,qBADJ,mBACzBC,EADyB,KACbC,EADa,OAKgBF,qBALhB,mBAKzBG,EALyB,KAKPC,EALO,KAO1BC,EAAcC,qBAAWC,KAEzBC,EAAUC,cAGVC,EAAWC,iBAA4B,MACvCC,EAAgBD,iBAAyB,MAEzCE,EAAiB,WACrBD,EAAcE,QAASC,SAkBnBC,EAAgB,uCAAG,4BAAAC,EAAA,yDAEvBC,QAAQC,IAAIC,IAAUC,kBAAkB,WACnCD,IAAUC,kBAAkB,UAHV,uBAIrBR,IAJqB,mDAQDjB,EAAO0B,SAAS,CAClCC,WAAYC,IAAiBC,IAC7BC,OAAQC,IAAa/B,OACrBgC,QAAS,GACTC,MAAO,MAZY,WAQfC,EARe,SAgBNA,EAAMC,QAhBA,mDAsBrB7B,EAAc,CACZ8B,KAAMF,EAAME,KAAOF,EAAME,KAAO,OAChCC,QAASH,EAAMC,UAxBI,kDA2BrBlB,IA3BqB,0DAAH,qDA+BhBqB,EAAgB,uCAAG,kCAAAjB,EAAA,yDACvBC,QAAQC,IAAI,WAENgB,EAHiB,UAGFzB,EAASI,eAHP,aAGF,EAAkBsB,MACvClB,QAAQC,IAAIlB,GACZiB,QAAQC,IAAIhB,GAGTgC,GACyC,IAA1CA,EAAaE,WAAWC,OAAOC,QAC9BtC,GACAE,EAXoB,uBAarBqC,MAAM,sBAbe,iCAiBjBC,GAAW,IAAIC,MAAOC,UAAY,QAExCzB,QAAQC,IAAIsB,GAnBW,UAuBFG,EAAe3C,EAAYgC,SAvBzB,QAuBjBY,EAvBiB,OAyBvB/C,EAAWgD,UAAU,CACnBd,KAAMS,EACNM,KAAMF,EACNG,UAAWC,IAAoBC,OAEjChC,QAAQC,IAAId,EAAY8C,WACxB9C,EAAY8C,UACVV,EACAI,EACAV,EAAaE,WACblC,GAGFK,EAAQ+B,OAAS,EAAI/B,EAAQ4C,SAAW5C,EAAQ6C,QAAQ,kBAtCjC,4CAAH,qDA8CtB,OACE,kBAAC,IAAD,KACE,kBAAC,IAAD,KACE,kBAAC,IAAD,KACE,kBAAC,IAAD,CAAYC,KAAK,SACf,kBAAC,IAAD,CAAeC,YAAY,oBAE7B,kBAAC,IAAD,yBAGJ,kBAAC,IAAD,KACE,0CACA,kBAAC,IAAD,KACE,kBAAC,IAAD,KACE,kBAAC,IAAD,KACE,kBAAC,IAAD,KACE,kBAAC,IAAD,CAAUC,SAAS,YAAnB,gBACA,kBAAC,IAAD,CAAUC,KAAK,OAAOC,IAAKhD,OAIjC,kBAAC,IAAD,KACE,kBAAC,IAAD,KACE,kBAAC,IAAD,CACEiD,YA7BkB,SAACC,GAC/B,IAAMC,EAAqBD,EAAME,OAAO1B,MACxChC,EAAoByD,IA4BRzB,MAAOjC,EACP4D,YAAY,cAEZ,kBAAC,IAAD,CAAiB3B,MAAM,QAAvB,eACA,kBAAC,IAAD,CAAiBA,MAAM,OAAvB,iBAIN,kBAAC,IAAD,CAAQ4B,UAAU,mBAChB,kBAAC,IAAD,KACE,yBAAKA,UAAU,kBACX/D,GAAc,+CACfA,GAAc,yBAAKgE,IAAKhE,EAAWgC,QAASiC,IAAI,aAEnD,kBAAC,IAAD,CAAWC,KAAK,QAAQC,QAASpD,GAC/B,kBAAC,IAAD,CAASqD,KAAMC,IAAQhB,KAAK,UAC5B,kBAAC,IAAD,oBAEF,2BACEG,KAAK,OACLc,QAAM,EACNb,IAAK9C,EACL4D,SA3IU,SAACZ,GACvB,IAAMa,EAAOb,EAAMc,OAAQC,MAAO,GAClCzD,QAAQC,IAAIsD,GAEZ,IAAMG,EAAK,IAAIC,WACfD,EAAGE,OAAS,WACV5E,EAAc,CACZ8B,UAAM+C,EACN9C,QAAS2C,EAAGI,OAAQ3C,cAIxBuC,EAAGK,cAAcR,QAmIX,kBAAC,IAAD,CAAQT,UAAU,kBAChB,kBAAC,IAAD,CAAQA,UAAU,mBAChB,kBAAC,IAAD,CAAWI,QAASlC,GAApB","file":"static/js/9.1bbd76ec.chunk.js","sourcesContent":["import { Capacitor } from '@capacitor/core';\nimport { FeatureNotAvailableError } from './models';\nconst allTrue = {\n    web: true,\n    ios: true,\n    android: true,\n    electron: true\n};\nconst featureMap = {\n    Accessibility: {\n        isScreenReaderAvailable: Object.assign(Object.assign({}, allTrue), { web: false }),\n        speak: {\n            web: 'speechSynthesis' in window,\n            ios: true,\n            android: true,\n            electron: true\n        }\n    },\n    App: {\n        state: allTrue,\n        getLaunchUrl: Object.assign(Object.assign({}, allTrue), { web: false }),\n        appUrlOpen: Object.assign(Object.assign({}, allTrue), { web: false })\n    },\n    Browser: {\n        open: allTrue,\n        prefetch: Object.assign(Object.assign({}, allTrue), { web: false }),\n        close: Object.assign(Object.assign({}, allTrue), { web: false })\n    },\n    Camera: {\n        getPhoto: allTrue\n    },\n    Clipboard: {\n        useClipboard: Object.assign(Object.assign({}, allTrue), { web: 'clipboard' in navigator }),\n    },\n    Device: {\n        getInfo: allTrue,\n        getLanguageCode: allTrue\n    },\n    FileSystem: {\n        useFileSystem: allTrue\n    },\n    Geolocation: {\n        getCurrentPosition: Object.assign(Object.assign({}, allTrue), { web: 'geolocation' in navigator }),\n        watchPosition: Object.assign(Object.assign({}, allTrue), { web: 'geolocation' in navigator })\n    },\n    Network: {\n        getStatus: allTrue\n    },\n    Platform: {\n        getPlatform: allTrue\n    },\n    Storage: {\n        useStorage: allTrue,\n    }\n};\nexport function isFeatureAvailable(plugin, method) {\n    if (Capacitor.isPluginAvailable(plugin) && !!featureMap[plugin][method][Capacitor.platform]) {\n        return true;\n    }\n    return false;\n}\nexport function featureNotAvailableError() {\n    throw new FeatureNotAvailableError();\n}\n//# sourceMappingURL=feature-check.js.map","export const notAvailable = {\n    isAvailable: false\n};\nexport class FeatureNotAvailableError extends Error {\n    constructor() {\n        super();\n        this.message = 'Feature not available on this platform/device. Check availability before attempting to call this method';\n        this.name = 'FeatreNotAvailableError';\n    }\n}\n//# sourceMappingURL=models.js.map","import { useCallback } from 'react';\nimport { Plugins } from '@capacitor/core';\nimport { isFeatureAvailable } from '../util/feature-check';\nexport const availableFeatures = {\n    useFileSystem: isFeatureAvailable('FileSystem', 'useFileSystem')\n};\nexport function useFilesystem() {\n    const { Filesystem } = Plugins;\n    const getUri = useCallback(async (options) => {\n        const result = await Filesystem.getUri(options);\n        return result;\n    }, []);\n    const deleteFile = useCallback(async (options) => {\n        const result = await Filesystem.deleteFile(options);\n        return result;\n    }, []);\n    const readFile = useCallback(async (options) => {\n        const result = await Filesystem.readFile(options);\n        return result;\n    }, []);\n    const writeFile = useCallback(async (options) => {\n        const result = await Filesystem.writeFile(options);\n        return result;\n    }, []);\n    return {\n        getUri,\n        deleteFile,\n        readFile,\n        writeFile,\n        isAvailable: true\n    };\n}\n//# sourceMappingURL=useFileSystem.js.map","export async function base64FromPath(path) {\n    const response = await fetch(path);\n    const blob = await response.blob();\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader;\n        reader.onerror = reject;\n        reader.onload = () => {\n            if (typeof reader.result === 'string') {\n                resolve(reader.result);\n            }\n            else {\n                reject('method did not return a string');\n            }\n        };\n        reader.readAsDataURL(blob);\n    });\n}\n//# sourceMappingURL=utils.js.map","import React, { useState, useRef, useContext } from \"react\";\nimport {\n  IonPage,\n  IonHeader,\n  IonToolbar,\n  IonTitle,\n  IonContent,\n  IonGrid,\n  IonRow,\n  IonCol,\n  IonItem,\n  IonLabel,\n  IonInput,\n  IonButton,\n  IonIcon,\n  IonButtons,\n  IonBackButton,\n  IonSelect,\n  IonSelectOption,\n} from \"@ionic/react\";\nimport { camera } from \"ionicons/icons\";\nimport {\n  Plugins,\n  CameraResultType,\n  CameraSource,\n  FilesystemDirectory,\n  Capacitor,\n} from \"@capacitor/core\";\nimport { base64FromPath } from \"@ionic/react-hooks/filesystem\";\nimport { useHistory } from \"react-router-dom\";\n\nimport MemoriesContext from \"../data/memory-context\";\nimport \"./NewMemory.css\";\n\nconst { Camera, Filesystem } = Plugins;\n\nconst NewMemory: React.FC = () => {\n  const [takenPhoto, setTakenPhoto] = useState<{\n    path: string | undefined;\n    preview: string;\n  }>();\n  const [chosenMemoryType, setChosenMemoryType] = useState<\"good\" | \"bad\">();\n\n  const memoriesCtx = useContext(MemoriesContext);\n\n  const history = useHistory();\n\n  //USING REF INSTEAD OF STATE TO SPICE THINGS UP :)\n  const titleRef = useRef<HTMLIonInputElement>(null);\n  const filePickerRef = useRef<HTMLInputElement>(null);\n\n  const openFilePicker = () => {\n    filePickerRef.current!.click();\n  };\n\n  const pickFileHandler = (event: React.ChangeEvent<HTMLInputElement>) => {\n    const file = event.target!.files![0];\n    console.log(file);\n    //this is an inbuilt JS Api\n    const fr = new FileReader();\n    fr.onload = () => {\n      setTakenPhoto({\n        path: undefined,\n        preview: fr.result!.toString(),\n      });\n    };\n\n    fr.readAsDataURL(file);\n  };\n\n  const takePhotoHandler = async () => {\n    //incase there is no file picker\n    console.log(Capacitor.isPluginAvailable(\"Camera\"));\n    if (!Capacitor.isPluginAvailable(\"Camera\")) {\n      openFilePicker();\n      return;\n    }\n    try {\n      const photo = await Camera.getPhoto({\n        resultType: CameraResultType.Uri,\n        source: CameraSource.Camera,\n        quality: 90,\n        width: 500,\n      });\n      // console.log(photo);\n\n      if (!photo || !photo.webPath) {\n        return;\n      }\n\n      //NOTE THAT IF STATEMENT HELPED TO REMOVE THE UNDEFINED ERROR TYPESCRIPT WAS\n      //SHOWING US.REMOVE IT TO SEE\n      setTakenPhoto({\n        path: photo.path ? photo.path : \"path\",\n        preview: photo.webPath,\n      });\n    } catch (error) {\n      openFilePicker();\n    }\n  };\n\n  const addMemoryHandler = async () => {\n    console.log(\"started\");\n    //get the content of the input\n    const enteredTitle = titleRef.current?.value;\n    console.log(takenPhoto);\n    console.log(chosenMemoryType);\n\n    if (\n      !enteredTitle ||\n      enteredTitle.toString().trim().length === 0 ||\n      !takenPhoto ||\n      !chosenMemoryType\n    ) {\n      alert(\"Select all options\");\n      return;\n    }\n\n    const fileName = new Date().getTime() + \".jpeg\";\n\n    console.log(fileName);\n\n    //Here wer converting the gotten photo preview to a base64 string and storing\n    //the base64 string as the data\n    const base64 = await base64FromPath(takenPhoto!.preview);\n\n    Filesystem.writeFile({\n      path: fileName,\n      data: base64,\n      directory: FilesystemDirectory.Data,\n    });\n    console.log(memoriesCtx.addMemory);\n    memoriesCtx.addMemory(\n      fileName,\n      base64,\n      enteredTitle.toString(),\n      chosenMemoryType\n    );\n\n    history.length > 0 ? history.goBack() : history.replace(\"/good-memories\");\n  };\n\n  const selectMemoryTypeHandler = (event: CustomEvent) => {\n    const selectedMemoryType = event.detail.value;\n    setChosenMemoryType(selectedMemoryType);\n  };\n\n  return (\n    <IonPage>\n      <IonHeader>\n        <IonToolbar>\n          <IonButtons slot=\"start\">\n            <IonBackButton defaultHref=\"/good-memories\" />\n          </IonButtons>\n          <IonTitle>Add New Memory</IonTitle>\n        </IonToolbar>\n      </IonHeader>\n      <IonContent>\n        <h2>New Memory</h2>\n        <IonGrid>\n          <IonRow>\n            <IonCol>\n              <IonItem>\n                <IonLabel position=\"floating\">Memory Title</IonLabel>\n                <IonInput type=\"text\" ref={titleRef}></IonInput>\n              </IonItem>\n            </IonCol>\n          </IonRow>\n          <IonRow>\n            <IonCol>\n              <IonSelect\n                onIonChange={selectMemoryTypeHandler}\n                value={chosenMemoryType}\n                placeholder=\"Select One\"\n              >\n                <IonSelectOption value=\"good\">Good Memory</IonSelectOption>\n                <IonSelectOption value=\"bad\">Bad Memory</IonSelectOption>\n              </IonSelect>\n            </IonCol>\n          </IonRow>\n          <IonRow className=\"ion-text-center\">\n            <IonCol>\n              <div className=\"image-preview\">\n                {!takenPhoto && <h3>No Photo Chosen</h3>}\n                {takenPhoto && <img src={takenPhoto.preview} alt=\"Preview\" />}\n              </div>\n              <IonButton fill=\"clear\" onClick={takePhotoHandler}>\n                <IonIcon icon={camera} slot=\"start\"></IonIcon>\n                <IonLabel>Take Photo</IonLabel>\n              </IonButton>\n              <input\n                type=\"file\"\n                hidden\n                ref={filePickerRef}\n                onChange={pickFileHandler}\n              />\n            </IonCol>\n          </IonRow>\n          <IonRow className=\"ion-margin-top\">\n            <IonCol className=\"ion-text-center\">\n              <IonButton onClick={addMemoryHandler}>Add Memory</IonButton>\n            </IonCol>\n          </IonRow>\n        </IonGrid>\n      </IonContent>\n    </IonPage>\n  );\n};\n\nexport default NewMemory;\n"],"sourceRoot":""}